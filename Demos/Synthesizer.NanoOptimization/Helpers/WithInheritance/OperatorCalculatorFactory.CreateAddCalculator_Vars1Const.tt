<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<# int minVarOperands = 1; #>
<# int maxVarOperands = 7; #>

using System;
using System.Collections.Generic;
using System.Linq;
using JJ.Framework.Reflection.Exceptions;
using JJ.Demos.Synthesizer.NanoOptimization.Calculation.Operators.WithInheritance;

namespace JJ.Demos.Synthesizer.NanoOptimization.Helpers.WithInheritance
{
    internal static partial class OperatorCalculatorFactory
    {
	    public static OperatorCalculatorBase CreateAddCalculator_Vars_1Const(IList<OperatorCalculatorBase> varOperandCalculators, double constValue)
        {
			if (varOperandCalculators.Count < <#= minVarOperands #>) throw new LessThanException(() => varOperandCalculators.Count, <#= minVarOperands #>);

            switch (varOperandCalculators.Count)
            {
<#
	for (int i = minVarOperands; i <= maxVarOperands; i++)
	{
#>
                case <#= i #>:
                    return new Add_OperatorCalculator_<#= i #>Vars_1Const
					(
<#
		for (int j = 0; j < i; j++)
		{
#>
						varOperandCalculators[<#=j#>],
<#
		}
#>						constValue
					);
<#
	}
#>
                default:
                    return new Add_OperatorCalculator_VarArray_1Const(varOperandCalculators, constValue);
            }
        }
	}
}
